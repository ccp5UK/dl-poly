project(DL_POLY Fortran)
cmake_minimum_required(VERSION 3.0.2)

set(DLPOLY_VERSION_MAJOR "4")
set(DLPOLY_VERSION_MINOR "09")
set(DLPOLY_VERSION_PATCH "00")
set(DLPOLY_VERSION "${DLPOLY_VERSION_MAJOR}.${DLPOLY_VERSION_MINOR}.${DLPOLY_VERSION_PATCH}")
set(AUTHOR "Ilian Todorov;Bill Smith")
set(AUTHOR_DETAILS "ilian.todorov@stfc.ac.uk")
set(DESCRIPTION "DL_POLY4 classical MD code")

set(src_dir ${CMAKE_SOURCE_DIR}/source)
set(target_name DLPOLY.Z)

set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/cmake" "${CMAKE_SOURCE_DIR}/cmake/Modules")
include(DLPOLYBuildOptions)
include(DLPOLYBuildFunctions)
include(GNUInstallDirs)
include(FeatureSummary)

if(COMMAND cmake_policy)
  #  cmake_policy(SET CMP0004 OLD)
endif(COMMAND cmake_policy)

if(WITH_MPI)
### if we want MPI check for it and set the internal kitchen
  find_package(MPI REQUIRED)
  include_directories(${MPI_Fortran_INCLUDE_PATH})
  message(STATUS "MPI_Fortran_INCLUDE_PATH ${MPI_Fortran_INCLUDE_PATH}")
  if(NOT WITH_PHI)
    set(LIBS ${LIBS} ${MPI_Fortran_LINK_FLAGS} ${MPI_Fortran_LIBRARIES})
  endif()
  message(STATUS "Build with MPI support!")
else()
  message(STATUS "Build without MPI support!")
endif()

if (BUILDER)
  message(STATUS "${BUILDER} is the builder")
else()
  message(STATUS "default value for builder will be used")
endif()
#if (NOT HOST)
#  message(STATUS "determining hostname...")
#  cmake_host_system_information(RESULT AH QUERY FQDN)
#  set(HOST "${AH}" CACHE STRING )
#endif()
message(STATUS "building on ${HOST}")

if(WITH_OPENMP)
   find_package(OpenMP REQUIRED)
   add_definitions(${OpenMP_Fortran_FLAGS})
   add_definitions(-D__OPENMP)
   set(OMP_LINK_FLAGS ${OpenMP_Fortran_FLAGS})
   message(STATUS "Build with OPENMP support")
else()
   message(STATUS "Build without OPENMP support")
endif()

if(WITH_PHI)
   add_definitions("-mmic")
   set(MIC_LINK_FLAGS "-mmic")
   message(STATUS "Build for Xeon Phi Native")
else()
   message(STATUS "Build for CPU host")
endif()

if(WITH_NETCDF)
  set(NETCDF_F90 "YES")
  find_package(NetCDF REQUIRED)
  include_directories(${NETCDF_INCLUDES_F90})
  set(LIBS ${LIBS} ${NETCDF_LIBRARIES})
  message(STATUS "Build with netcdf support")
else()
  message(STATUS "Build without netcdf support")
endif()

if(WITH_KIM)
   find_package(KIM 1.7.1 REQUIRED)
   include_directories(${KIM_MODULE_DIRS})
   message(STATUS "Build with KIM support")
   set(LIBS ${LIBS} ${KIM_LIBRARIES})
else()
   message(STATUS "Build without KIM support")
endif()

if(WITH_PLUMED)
   find_package(PLUMED 2.1 REQUIRED)
   message(STATUS "Build with PLUMED support")
   set(LIBS ${LIBS} ${PLUMED_LIBRARIES})
else()
   message(STATUS "Build without PLUMED support")
endif()

if(WITH_EXTRATIME)
   add_definitions("-DCHRONO")
   message(STATUS "Build with extra timing support")
   message(STATUS "Use only for development")
else()
   message(STATUS "Build without extra timing support")
endif()
######################

###documentation
if (DOCS)
   message(STATUS "Build Doxygen API Documentation")
  set(doc_dir doc)
  find_package(Doxygen REQUIRED)
  find_package(Ford REQUIRED)
endif()
######################
##set the output folder for libs and bins
set(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})

add_subdirectory(source)
  configure_file(${CMAKE_SOURCE_DIR}/cmake/modulefile.cmake modulefile)

if(DOCS)
  configure_file(${CMAKE_SOURCE_DIR}/cmake/Doxyfile.cmake Doxyfile)
  add_custom_target(docs
    ${DOXYGEN_EXECUTABLE} ${PROJECT_BINARY_DIR}/Doxyfile)
  install(CODE "execute_process(COMMAND ${CMAKE_BUILD_TOOL} docs)")
  install(DIRECTORY ${CMAKE_BINARY_DIR}/doc/html/ DESTINATION ${CMAKE_INSTALL_DOCDIR})

  configure_file(${CMAKE_SOURCE_DIR}/cmake/dlpoly.md.cmake dlpoly.md)
  add_custom_target(ford
    ${FORD_EXECUTABLE} ${PROJECT_BINARY_DIR}/dlpoly.md)

endif(DOCS)

if (WITH_COVERAGE)
  include(CodeCoverage)
  set(BUILD_TESTING ON)
  setup_coverage(coverage coverage)
  file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/CodeAnalysis)
  if (MPIEXEC)
    set(dlp "${MPIEXEC} -n ${MPI_NPROCS} ${CMAKE_BINARY_DIR}/bin/${target_name}")
  else()
    set(dlp "${CMAKE_BINARY_DIR}/bin/${target_name}")
  endif()
  single_coverage(runcoverage coverage "${CMAKE_BINARY_DIR}/bin/${target_name}" CodeAnalysis)
else()
  message(STATUS "Build without code coverage testing")
endif()

if (BUILD_TESTING AND NOT WITH_MPI)
  message(STATUS "testing is supported only with MPI")
endif()

if (WITH_COVERAGE AND NOT WITH_MPI)
  message(STATUS "code coverage is supported only with MPI")
endif()

if(WITH_FORCHECK)
  message(STATUS "Build with forcheck support support: make forcheck")
  set(FORCHECK_EXECUTABLE forchk)
  set(FORCHECK_FLAGS "-I ${CMAKE_SOURCE_DIR}/source,${CMAKE_SOURCE_DIR}/source/VV,${CMAKE_SOURCE_DIR}/source/LFV")
  if(NOT WITH_MPI)
    set(FORCHECK_FLAGS "${FORCHECK_FLAGS},${CMAKE_SOURCE_DIR}/source/SERIAL")
  endif()
  set(FORCHECK_FLAGS "${FORCHECK_FLAGS} -l ${CMAKE_BINARY_DIR}/${target_name}.lst")
  set(FORCHECK_FLAGS "${FORCHECK_FLAGS} -allc -ff -f08 -ancmpl -anref -rigorous -anprg -cpp")
  unset(fors)
  unset(defs)
  foreach(t dlpolycore dlpoly dlpolylfv dlpolyvv dlpolythermo dlpolykim dlpolyplumed ${target_name})
    get_target_property(srcs ${t} SOURCES)
    get_target_property(fld ${t} SOURCE_DIR)
    get_target_property(def ${t} COMPILE_DEFINITIONS)
    if (def)
      list(APPEND defs ${def})
    endif()
    foreach(f ${srcs})
      list(APPEND fors ${fld}/${f})
    endforeach()
  endforeach()
  set(mpi $ENV{FCKDIR}/share/forcheck/MPI_3.flb)
  if(defs)
    set(define "-define ${defs}")
  endif()
  add_custom_target(forcheck
    ${FORCHECK_EXECUTABLE} ${FORCHECK_FLAGS} ${fors} ${mpi}
    )
else()
  message(STATUS "Build without forcheck support!")
endif()

if(BUILD_TESTING)
  include(CTest)
  message(STATUS "Build with testing support support: make test")
  find_package(PythonInterp 3.0 REQUIRED)
  macro (do_test arg)
    if (EXISTS ${CMAKE_SOURCE_DIR}/data/${arg}.tar.gz)
      message(STATUS "Using already downloaded ${arg}.tar.gz")
    else()
      message(STATUS "Trying to download ${arg}.tar.gz")
      file(DOWNLOAD ftp://ftp.dl.ac.uk/ccp5/DL_POLY/DL_POLY_4.0/DATA/${DLPOLY_VERSION_MAJOR}.${DLPOLY_VERSION_MINOR}/${arg}.tar.gz
        ${CMAKE_SOURCE_DIR}/data/${arg}.tar.gz)
    endif()
    file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/Testing/${arg})
    file(COPY ${CMAKE_SOURCE_DIR}/data/${arg}.tar.gz
      DESTINATION ${CMAKE_BINARY_DIR}/Testing/${arg}/)
    add_test(NAME ${arg}
      COMMAND ${PYTHON_EXECUTABLE} ${CMAKE_SOURCE_DIR}/utils/beetest -f all.xml -v -k -s all -t ${arg} "${dlp}"
      WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/Testing)
    set_tests_properties (${arg}
      PROPERTIES PASS_REGULAR_EXPRESSION "Status: PASSED")
  endmacro (do_test)
  configure_file(${CMAKE_SOURCE_DIR}/cmake/all.xml.cmake Testing/all.xml)

  set(dlp "${MPIEXEC} -n ${MPI_NPROCS} ${CMAKE_BINARY_DIR}/bin/${target_name}")
  foreach(test RANGE 1 9 1)
    do_test("TEST0${test}")
  endforeach()
  foreach(test RANGE 10 25 1)
    do_test("TEST${test}")
  endforeach()
  #do_test("TEST28")

else()
  message(STATUS "Build without testing target")
endif()

feature_summary(WHAT ALL FATAL_ON_MISSING_REQUIRED_PACKAGES)

