From 9c62259cbf97cbb5264d7998f20da4e5ef1f9518 Mon Sep 17 00:00:00 2001
From: Alin Marin Elena <alin@elena.space>
Date: Tue, 28 Jul 2015 10:24:16 +0100
Subject: [PATCH] fix template issue for optimalAlignment

---
 src/tools/RMSD.cpp | 226 ----------------------------------------------------
 src/tools/RMSD.h   | 230 +++++++++++++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 225 insertions(+), 231 deletions(-)

diff --git a/src/tools/RMSD.cpp b/src/tools/RMSD.cpp
index a8bdfce..296d11d 100644
--- a/src/tools/RMSD.cpp
+++ b/src/tools/RMSD.cpp
@@ -333,232 +333,6 @@ double RMSD::simpleAlignment(const  std::vector<double>  & align,
       return dist;
 }
 
-// this below enable the standard case for rmsd where the rmsd is calculated and the derivative of rmsd respect to positions is retrieved
-// additionally this assumes that the com of the reference is already subtracted.    
-#define OLDRMSD
-#ifdef OLDRMSD
-// notice that in the current implementation the safe argument only makes sense for
-// align==displace
-template <bool safe,bool alEqDis>
-double RMSD::optimalAlignment(const  std::vector<double>  & align,
-                                     const  std::vector<double>  & displace,
-                                     const std::vector<Vector> & positions,
-                                     const std::vector<Vector> & reference ,
-                                     std::vector<Vector>  & derivatives, bool squared)const{
-  double dist(0);
-  const unsigned n=reference.size();
-// This is the trace of positions*positions + reference*reference
-  double rr00(0);
-  double rr11(0);
-// This is positions*reference
-  Tensor rr01;
-
-  derivatives.resize(n);
-
-  Vector cpositions;
-
-// first expensive loop: compute centers
-  for(unsigned iat=0;iat<n;iat++){
-    double w=align[iat];
-    cpositions+=positions[iat]*w;
-  }
-
-// second expensive loop: compute second moments wrt centers
-  for(unsigned iat=0;iat<n;iat++){
-    double w=align[iat];
-    rr00+=dotProduct(positions[iat]-cpositions,positions[iat]-cpositions)*w;
-    rr11+=dotProduct(reference[iat],reference[iat])*w;
-    rr01+=Tensor(positions[iat]-cpositions,reference[iat])*w;
-  }
-
-  Matrix<double> m=Matrix<double>(4,4);
-  m[0][0]=2.0*(-rr01[0][0]-rr01[1][1]-rr01[2][2]);
-  m[1][1]=2.0*(-rr01[0][0]+rr01[1][1]+rr01[2][2]);
-  m[2][2]=2.0*(+rr01[0][0]-rr01[1][1]+rr01[2][2]);
-  m[3][3]=2.0*(+rr01[0][0]+rr01[1][1]-rr01[2][2]);
-  m[0][1]=2.0*(-rr01[1][2]+rr01[2][1]);
-  m[0][2]=2.0*(+rr01[0][2]-rr01[2][0]);
-  m[0][3]=2.0*(-rr01[0][1]+rr01[1][0]);
-  m[1][2]=2.0*(-rr01[0][1]-rr01[1][0]);
-  m[1][3]=2.0*(-rr01[0][2]-rr01[2][0]);
-  m[2][3]=2.0*(-rr01[1][2]-rr01[2][1]);
-  m[1][0] = m[0][1];
-  m[2][0] = m[0][2];
-  m[2][1] = m[1][2];
-  m[3][0] = m[0][3];
-  m[3][1] = m[1][3];
-  m[3][2] = m[2][3];
-
-  Tensor dm_drr01[4][4];
-  if(!alEqDis){
-    dm_drr01[0][0] = 2.0*Tensor(-1.0, 0.0, 0.0,  0.0,-1.0, 0.0,  0.0, 0.0,-1.0);
-    dm_drr01[1][1] = 2.0*Tensor(-1.0, 0.0, 0.0,  0.0,+1.0, 0.0,  0.0, 0.0,+1.0);
-    dm_drr01[2][2] = 2.0*Tensor(+1.0, 0.0, 0.0,  0.0,-1.0, 0.0,  0.0, 0.0,+1.0);
-    dm_drr01[3][3] = 2.0*Tensor(+1.0, 0.0, 0.0,  0.0,+1.0, 0.0,  0.0, 0.0,-1.0);
-    dm_drr01[0][1] = 2.0*Tensor( 0.0, 0.0, 0.0,  0.0, 0.0,-1.0,  0.0,+1.0, 0.0);
-    dm_drr01[0][2] = 2.0*Tensor( 0.0, 0.0,+1.0,  0.0, 0.0, 0.0, -1.0, 0.0, 0.0);
-    dm_drr01[0][3] = 2.0*Tensor( 0.0,-1.0, 0.0, +1.0, 0.0, 0.0,  0.0, 0.0, 0.0);
-    dm_drr01[1][2] = 2.0*Tensor( 0.0,-1.0, 0.0, -1.0, 0.0, 0.0,  0.0, 0.0, 0.0);
-    dm_drr01[1][3] = 2.0*Tensor( 0.0, 0.0,-1.0,  0.0, 0.0, 0.0, -1.0, 0.0, 0.0);
-    dm_drr01[2][3] = 2.0*Tensor( 0.0, 0.0, 0.0,  0.0, 0.0,-1.0,  0.0,-1.0, 0.0);
-    dm_drr01[1][0] = dm_drr01[0][1];
-    dm_drr01[2][0] = dm_drr01[0][2];
-    dm_drr01[2][1] = dm_drr01[1][2];
-    dm_drr01[3][0] = dm_drr01[0][3];
-    dm_drr01[3][1] = dm_drr01[1][3];
-    dm_drr01[3][2] = dm_drr01[2][3];
-  }
-
-  vector<double> eigenvals;
-  Matrix<double> eigenvecs;
-  int diagerror=diagMat(m, eigenvals, eigenvecs );
-
-  if (diagerror!=0){
-    string sdiagerror;
-    Tools::convert(diagerror,sdiagerror);
-    string msg="DIAGONALIZATION FAILED WITH ERROR CODE "+sdiagerror;
-    plumed_merror(msg);
-  }
-
-  dist=eigenvals[0]+rr00+rr11;
-
-  Matrix<double> ddist_dm(4,4);
-
-  Vector4d q(eigenvecs[0][0],eigenvecs[0][1],eigenvecs[0][2],eigenvecs[0][3]);
-
-  Tensor dq_drr01[4];
-  if(!alEqDis){
-    double dq_dm[4][4][4];
-    for(unsigned i=0;i<4;i++) for(unsigned j=0;j<4;j++) for(unsigned k=0;k<4;k++){
-      double tmp=0.0;
-// perturbation theory for matrix m
-      for(unsigned l=1;l<4;l++) tmp+=eigenvecs[l][j]*eigenvecs[l][i]/(eigenvals[0]-eigenvals[l])*eigenvecs[0][k];
-      dq_dm[i][j][k]=tmp;
-    }
-// propagation to _drr01
-    for(unsigned i=0;i<4;i++){
-      Tensor tmp;
-      for(unsigned j=0;j<4;j++) for(unsigned k=0;k<4;k++) {
-        tmp+=dq_dm[i][j][k]*dm_drr01[j][k];
-      }
-      dq_drr01[i]=tmp;
-    }
-  }
-
-// This is the rotation matrix that brings reference to positions
-// i.e. matmul(rotation,reference[iat])+shift is fitted to positions[iat]
-
-  Tensor rotation;
-  rotation[0][0]=q[0]*q[0]+q[1]*q[1]-q[2]*q[2]-q[3]*q[3];
-  rotation[1][1]=q[0]*q[0]-q[1]*q[1]+q[2]*q[2]-q[3]*q[3];
-  rotation[2][2]=q[0]*q[0]-q[1]*q[1]-q[2]*q[2]+q[3]*q[3];
-  rotation[0][1]=2*(+q[0]*q[3]+q[1]*q[2]);
-  rotation[0][2]=2*(-q[0]*q[2]+q[1]*q[3]);
-  rotation[1][2]=2*(+q[0]*q[1]+q[2]*q[3]);
-  rotation[1][0]=2*(-q[0]*q[3]+q[1]*q[2]);
-  rotation[2][0]=2*(+q[0]*q[2]+q[1]*q[3]);
-  rotation[2][1]=2*(-q[0]*q[1]+q[2]*q[3]);
-
-  
-  Tensor drotation_drr01[3][3];
-  if(!alEqDis){
-    drotation_drr01[0][0]=2*q[0]*dq_drr01[0]+2*q[1]*dq_drr01[1]-2*q[2]*dq_drr01[2]-2*q[3]*dq_drr01[3];
-    drotation_drr01[1][1]=2*q[0]*dq_drr01[0]-2*q[1]*dq_drr01[1]+2*q[2]*dq_drr01[2]-2*q[3]*dq_drr01[3];
-    drotation_drr01[2][2]=2*q[0]*dq_drr01[0]-2*q[1]*dq_drr01[1]-2*q[2]*dq_drr01[2]+2*q[3]*dq_drr01[3];
-    drotation_drr01[0][1]=2*(+(q[0]*dq_drr01[3]+dq_drr01[0]*q[3])+(q[1]*dq_drr01[2]+dq_drr01[1]*q[2]));
-    drotation_drr01[0][2]=2*(-(q[0]*dq_drr01[2]+dq_drr01[0]*q[2])+(q[1]*dq_drr01[3]+dq_drr01[1]*q[3]));
-    drotation_drr01[1][2]=2*(+(q[0]*dq_drr01[1]+dq_drr01[0]*q[1])+(q[2]*dq_drr01[3]+dq_drr01[2]*q[3]));
-    drotation_drr01[1][0]=2*(-(q[0]*dq_drr01[3]+dq_drr01[0]*q[3])+(q[1]*dq_drr01[2]+dq_drr01[1]*q[2]));
-    drotation_drr01[2][0]=2*(+(q[0]*dq_drr01[2]+dq_drr01[0]*q[2])+(q[1]*dq_drr01[3]+dq_drr01[1]*q[3]));
-    drotation_drr01[2][1]=2*(-(q[0]*dq_drr01[1]+dq_drr01[0]*q[1])+(q[2]*dq_drr01[3]+dq_drr01[2]*q[3]));
-  }
-
-  double prefactor=2.0;
-
-  if(!squared && alEqDis) prefactor*=0.5/sqrt(dist);
-
-// if "safe", recompute dist here to a better accuracy
-  if(safe || !alEqDis) dist=0.0;
-
-// If safe is set to "false", MSD is taken from the eigenvalue of the M matrix
-// If safe is set to "true", MSD is recomputed from the rotational matrix
-// For some reason, this last approach leads to less numerical noise but adds an overhead
-
-  Tensor ddist_drotation;
-  Vector ddist_dcpositions;
-
-// third expensive loop: derivatives
-  for(unsigned iat=0;iat<n;iat++){
-    Vector d(positions[iat]-cpositions - matmul(rotation,reference[iat]));
-    if(alEqDis){
-// there is no need for derivatives of rotation and shift here as it is by construction zero
-// (similar to Hellman-Feynman forces)
-      derivatives[iat]= prefactor*align[iat]*d;
-       if(safe) dist+=align[iat]*modulo2(d);
-    } else {
-// the case for align != displace is different, sob:
-      dist+=displace[iat]*modulo2(d);
-// these are the derivatives assuming the roto-translation as frozen
-      derivatives[iat]=2*displace[iat]*d;
-// here I accumulate derivatives wrt rotation matrix ..
-      ddist_drotation+=-2*displace[iat]*extProduct(d,reference[iat]);
-// .. and cpositions
-      ddist_dcpositions+=-2*displace[iat]*d;
-    }
-  }
-
-  if(!alEqDis){
-    Tensor ddist_drr01;
-    for(unsigned i=0;i<3;i++) for(unsigned j=0;j<3;j++) ddist_drr01+=ddist_drotation[i][j]*drotation_drr01[i][j];
-    for(unsigned iat=0;iat<n;iat++){
-// this is propagating to positions.
-// I am implicitly using the derivative of rr01 wrt positions here
-      derivatives[iat]+=matmul(ddist_drr01,reference[iat])*align[iat];
-      derivatives[iat]+=ddist_dcpositions*align[iat];
-    }
-  }
-  if(!squared){
-    dist=sqrt(dist);
-    if(!alEqDis){
-      double xx=0.5/dist;
-      for(unsigned iat=0;iat<n;iat++) derivatives[iat]*=xx;
-    }
-  }
-
-  return dist;
-}
-#else
-/// note that this method is intended to be repeatedly invoked 
-/// when the reference does already have the center subtracted
-/// but the position has not calculated center and not subtracted 
-template <bool safe,bool alEqDis>
-double RMSD::optimalAlignment(const  std::vector<double>  & align,
-                              const  std::vector<double>  & displace,
-                              const std::vector<Vector> & positions,
-			      const std::vector<Vector> & reference ,
-			      std::vector<Vector>  & derivatives,		
-                              bool squared) const {
-   //std::cerr<<"setting up the core data \n"; 
-   RMSDCoreData cd(align,displace,positions,reference); 
-
-   // transfer the settings for the center to let the CoreCalc deal with it 
-   cd.setPositionsCenterIsRemoved(positions_center_is_removed);
-   if(positions_center_is_calculated){cd.setPositionsCenter(positions_center);}
-   else{cd.calcPositionsCenter();};
-
-   cd.setReferenceCenterIsRemoved(reference_center_is_removed);
-   if(!reference_center_is_calculated){cd.calcReferenceCenter();}
-   else{cd.setReferenceCenter(reference_center);}
-
-   // Perform the diagonalization and all the needed stuff
-   cd.doCoreCalc(safe,alEqDis); 
-   // make the core calc distance
-   double dist=cd.getDistance(squared); 
-//  make the derivatives by using pieces calculated in coreCalc (probably the best is just to copy the vector...) 
-   derivatives=cd.getDDistanceDPositions(); 
-   return dist;    
-}
-#endif
 template <bool safe,bool alEqDis>
 double RMSD::optimalAlignment_DDistDRef(const  std::vector<double>  & align,
                               const  std::vector<double>  & displace,
diff --git a/src/tools/RMSD.h b/src/tools/RMSD.h
index 6681984..ceb1b95 100644
--- a/src/tools/RMSD.h
+++ b/src/tools/RMSD.h
@@ -121,12 +121,232 @@ public:
   		                     std::vector<Vector>  & derivatives, 
                                      std::vector<Vector>  & displacement, 
                                      bool squared=false)const;
+// this below enable the standard case for rmsd where the rmsd is calculated and the derivative of rmsd respect to positions is retrieved
+// additionally this assumes that the com of the reference is already subtracted.    
+#define OLDRMSD
+#ifdef OLDRMSD
+// notice that in the current implementation the safe argument only makes sense for
+// align==displace
 template <bool safe,bool alEqDis>
-  double optimalAlignment(const  std::vector<double>  & align,
-                          const  std::vector<double>  & displace,
-                          const std::vector<Vector> & positions,
-                          const std::vector<Vector> & reference ,
-                          std::vector<Vector>  & DDistDPos, bool squared=false)const;
+double optimalAlignment(const  std::vector<double>  & align,
+                                     const  std::vector<double>  & displace,
+                                     const std::vector<Vector> & positions,
+                                     const std::vector<Vector> & reference ,
+                                     std::vector<Vector>  & derivatives, bool squared)const{
+  double dist(0);
+  const unsigned n=reference.size();
+// This is the trace of positions*positions + reference*reference
+  double rr00(0);
+  double rr11(0);
+// This is positions*reference
+  Tensor rr01;
+
+  derivatives.resize(n);
+
+  Vector cpositions;
+
+// first expensive loop: compute centers
+  for(unsigned iat=0;iat<n;iat++){
+    double w=align[iat];
+    cpositions+=positions[iat]*w;
+  }
+
+// second expensive loop: compute second moments wrt centers
+  for(unsigned iat=0;iat<n;iat++){
+    double w=align[iat];
+    rr00+=dotProduct(positions[iat]-cpositions,positions[iat]-cpositions)*w;
+    rr11+=dotProduct(reference[iat],reference[iat])*w;
+    rr01+=Tensor(positions[iat]-cpositions,reference[iat])*w;
+  }
+
+  Matrix<double> m=Matrix<double>(4,4);
+  m[0][0]=2.0*(-rr01[0][0]-rr01[1][1]-rr01[2][2]);
+  m[1][1]=2.0*(-rr01[0][0]+rr01[1][1]+rr01[2][2]);
+  m[2][2]=2.0*(+rr01[0][0]-rr01[1][1]+rr01[2][2]);
+  m[3][3]=2.0*(+rr01[0][0]+rr01[1][1]-rr01[2][2]);
+  m[0][1]=2.0*(-rr01[1][2]+rr01[2][1]);
+  m[0][2]=2.0*(+rr01[0][2]-rr01[2][0]);
+  m[0][3]=2.0*(-rr01[0][1]+rr01[1][0]);
+  m[1][2]=2.0*(-rr01[0][1]-rr01[1][0]);
+  m[1][3]=2.0*(-rr01[0][2]-rr01[2][0]);
+  m[2][3]=2.0*(-rr01[1][2]-rr01[2][1]);
+  m[1][0] = m[0][1];
+  m[2][0] = m[0][2];
+  m[2][1] = m[1][2];
+  m[3][0] = m[0][3];
+  m[3][1] = m[1][3];
+  m[3][2] = m[2][3];
+
+  Tensor dm_drr01[4][4];
+  if(!alEqDis){
+    dm_drr01[0][0] = 2.0*Tensor(-1.0, 0.0, 0.0,  0.0,-1.0, 0.0,  0.0, 0.0,-1.0);
+    dm_drr01[1][1] = 2.0*Tensor(-1.0, 0.0, 0.0,  0.0,+1.0, 0.0,  0.0, 0.0,+1.0);
+    dm_drr01[2][2] = 2.0*Tensor(+1.0, 0.0, 0.0,  0.0,-1.0, 0.0,  0.0, 0.0,+1.0);
+    dm_drr01[3][3] = 2.0*Tensor(+1.0, 0.0, 0.0,  0.0,+1.0, 0.0,  0.0, 0.0,-1.0);
+    dm_drr01[0][1] = 2.0*Tensor( 0.0, 0.0, 0.0,  0.0, 0.0,-1.0,  0.0,+1.0, 0.0);
+    dm_drr01[0][2] = 2.0*Tensor( 0.0, 0.0,+1.0,  0.0, 0.0, 0.0, -1.0, 0.0, 0.0);
+    dm_drr01[0][3] = 2.0*Tensor( 0.0,-1.0, 0.0, +1.0, 0.0, 0.0,  0.0, 0.0, 0.0);
+    dm_drr01[1][2] = 2.0*Tensor( 0.0,-1.0, 0.0, -1.0, 0.0, 0.0,  0.0, 0.0, 0.0);
+    dm_drr01[1][3] = 2.0*Tensor( 0.0, 0.0,-1.0,  0.0, 0.0, 0.0, -1.0, 0.0, 0.0);
+    dm_drr01[2][3] = 2.0*Tensor( 0.0, 0.0, 0.0,  0.0, 0.0,-1.0,  0.0,-1.0, 0.0);
+    dm_drr01[1][0] = dm_drr01[0][1];
+    dm_drr01[2][0] = dm_drr01[0][2];
+    dm_drr01[2][1] = dm_drr01[1][2];
+    dm_drr01[3][0] = dm_drr01[0][3];
+    dm_drr01[3][1] = dm_drr01[1][3];
+    dm_drr01[3][2] = dm_drr01[2][3];
+  }
+
+  std::vector<double> eigenvals;
+  Matrix<double> eigenvecs;
+  int diagerror=diagMat(m, eigenvals, eigenvecs );
+
+  if (diagerror!=0){
+    std::string sdiagerror;
+    Tools::convert(diagerror,sdiagerror);
+    std::string msg="DIAGONALIZATION FAILED WITH ERROR CODE "+sdiagerror;
+    plumed_merror(msg);
+  }
+
+  dist=eigenvals[0]+rr00+rr11;
+
+  Matrix<double> ddist_dm(4,4);
+
+  Vector4d q(eigenvecs[0][0],eigenvecs[0][1],eigenvecs[0][2],eigenvecs[0][3]);
+
+  Tensor dq_drr01[4];
+  if(!alEqDis){
+    double dq_dm[4][4][4];
+    for(unsigned i=0;i<4;i++) for(unsigned j=0;j<4;j++) for(unsigned k=0;k<4;k++){
+      double tmp=0.0;
+// perturbation theory for matrix m
+      for(unsigned l=1;l<4;l++) tmp+=eigenvecs[l][j]*eigenvecs[l][i]/(eigenvals[0]-eigenvals[l])*eigenvecs[0][k];
+      dq_dm[i][j][k]=tmp;
+    }
+// propagation to _drr01
+    for(unsigned i=0;i<4;i++){
+      Tensor tmp;
+      for(unsigned j=0;j<4;j++) for(unsigned k=0;k<4;k++) {
+        tmp+=dq_dm[i][j][k]*dm_drr01[j][k];
+      }
+      dq_drr01[i]=tmp;
+    }
+  }
+
+// This is the rotation matrix that brings reference to positions
+// i.e. matmul(rotation,reference[iat])+shift is fitted to positions[iat]
+
+  Tensor rotation;
+  rotation[0][0]=q[0]*q[0]+q[1]*q[1]-q[2]*q[2]-q[3]*q[3];
+  rotation[1][1]=q[0]*q[0]-q[1]*q[1]+q[2]*q[2]-q[3]*q[3];
+  rotation[2][2]=q[0]*q[0]-q[1]*q[1]-q[2]*q[2]+q[3]*q[3];
+  rotation[0][1]=2*(+q[0]*q[3]+q[1]*q[2]);
+  rotation[0][2]=2*(-q[0]*q[2]+q[1]*q[3]);
+  rotation[1][2]=2*(+q[0]*q[1]+q[2]*q[3]);
+  rotation[1][0]=2*(-q[0]*q[3]+q[1]*q[2]);
+  rotation[2][0]=2*(+q[0]*q[2]+q[1]*q[3]);
+  rotation[2][1]=2*(-q[0]*q[1]+q[2]*q[3]);
+
+  
+  Tensor drotation_drr01[3][3];
+  if(!alEqDis){
+    drotation_drr01[0][0]=2*q[0]*dq_drr01[0]+2*q[1]*dq_drr01[1]-2*q[2]*dq_drr01[2]-2*q[3]*dq_drr01[3];
+    drotation_drr01[1][1]=2*q[0]*dq_drr01[0]-2*q[1]*dq_drr01[1]+2*q[2]*dq_drr01[2]-2*q[3]*dq_drr01[3];
+    drotation_drr01[2][2]=2*q[0]*dq_drr01[0]-2*q[1]*dq_drr01[1]-2*q[2]*dq_drr01[2]+2*q[3]*dq_drr01[3];
+    drotation_drr01[0][1]=2*(+(q[0]*dq_drr01[3]+dq_drr01[0]*q[3])+(q[1]*dq_drr01[2]+dq_drr01[1]*q[2]));
+    drotation_drr01[0][2]=2*(-(q[0]*dq_drr01[2]+dq_drr01[0]*q[2])+(q[1]*dq_drr01[3]+dq_drr01[1]*q[3]));
+    drotation_drr01[1][2]=2*(+(q[0]*dq_drr01[1]+dq_drr01[0]*q[1])+(q[2]*dq_drr01[3]+dq_drr01[2]*q[3]));
+    drotation_drr01[1][0]=2*(-(q[0]*dq_drr01[3]+dq_drr01[0]*q[3])+(q[1]*dq_drr01[2]+dq_drr01[1]*q[2]));
+    drotation_drr01[2][0]=2*(+(q[0]*dq_drr01[2]+dq_drr01[0]*q[2])+(q[1]*dq_drr01[3]+dq_drr01[1]*q[3]));
+    drotation_drr01[2][1]=2*(-(q[0]*dq_drr01[1]+dq_drr01[0]*q[1])+(q[2]*dq_drr01[3]+dq_drr01[2]*q[3]));
+  }
+
+  double prefactor=2.0;
+
+  if(!squared && alEqDis) prefactor*=0.5/sqrt(dist);
+
+// if "safe", recompute dist here to a better accuracy
+  if(safe || !alEqDis) dist=0.0;
+
+// If safe is set to "false", MSD is taken from the eigenvalue of the M matrix
+// If safe is set to "true", MSD is recomputed from the rotational matrix
+// For some reason, this last approach leads to less numerical noise but adds an overhead
+
+  Tensor ddist_drotation;
+  Vector ddist_dcpositions;
+
+// third expensive loop: derivatives
+  for(unsigned iat=0;iat<n;iat++){
+    Vector d(positions[iat]-cpositions - matmul(rotation,reference[iat]));
+    if(alEqDis){
+// there is no need for derivatives of rotation and shift here as it is by construction zero
+// (similar to Hellman-Feynman forces)
+      derivatives[iat]= prefactor*align[iat]*d;
+       if(safe) dist+=align[iat]*modulo2(d);
+    } else {
+// the case for align != displace is different, sob:
+      dist+=displace[iat]*modulo2(d);
+// these are the derivatives assuming the roto-translation as frozen
+      derivatives[iat]=2*displace[iat]*d;
+// here I accumulate derivatives wrt rotation matrix ..
+      ddist_drotation+=-2*displace[iat]*extProduct(d,reference[iat]);
+// .. and cpositions
+      ddist_dcpositions+=-2*displace[iat]*d;
+    }
+  }
+
+  if(!alEqDis){
+    Tensor ddist_drr01;
+    for(unsigned i=0;i<3;i++) for(unsigned j=0;j<3;j++) ddist_drr01+=ddist_drotation[i][j]*drotation_drr01[i][j];
+    for(unsigned iat=0;iat<n;iat++){
+// this is propagating to positions.
+// I am implicitly using the derivative of rr01 wrt positions here
+      derivatives[iat]+=matmul(ddist_drr01,reference[iat])*align[iat];
+      derivatives[iat]+=ddist_dcpositions*align[iat];
+    }
+  }
+  if(!squared){
+    dist=sqrt(dist);
+    if(!alEqDis){
+      double xx=0.5/dist;
+      for(unsigned iat=0;iat<n;iat++) derivatives[iat]*=xx;
+    }
+  }
+
+  return dist;
+}
+#else
+/// note that this method is intended to be repeatedly invoked 
+/// when the reference does already have the center subtracted
+/// but the position has not calculated center and not subtracted 
+template <bool safe,bool alEqDis>
+double optimalAlignment(const  std::vector<double>  & align,
+                              const  std::vector<double>  & displace,
+                              const std::vector<Vector> & positions,
+			      const std::vector<Vector> & reference ,
+			      std::vector<Vector>  & derivatives,		
+                              bool squared) const {
+   //std::cerr<<"setting up the core data \n"; 
+   RMSDCoreData cd(align,displace,positions,reference); 
+
+   // transfer the settings for the center to let the CoreCalc deal with it 
+   cd.setPositionsCenterIsRemoved(positions_center_is_removed);
+   if(positions_center_is_calculated){cd.setPositionsCenter(positions_center);}
+   else{cd.calcPositionsCenter();};
+
+   cd.setReferenceCenterIsRemoved(reference_center_is_removed);
+   if(!reference_center_is_calculated){cd.calcReferenceCenter();}
+   else{cd.setReferenceCenter(reference_center);}
+
+   // Perform the diagonalization and all the needed stuff
+   cd.doCoreCalc(safe,alEqDis); 
+   // make the core calc distance
+   double dist=cd.getDistance(squared); 
+//  make the derivatives by using pieces calculated in coreCalc (probably the best is just to copy the vector...) 
+   derivatives=cd.getDDistanceDPositions(); 
+   return dist;
+}
+#endif
 
 template <bool safe,bool alEqDis>
 double optimalAlignment_DDistDRef(const  std::vector<double>  & align,
-- 
2.4.6

